/******************************************************************************
 * @file			rc_transmitter.c
 * @author		Skywalker
 * @brief			STM32 user peripheral library for Futaba transmitter
							Decode PPM signal from trainer port.
							For T10CG, edge-to-edge time of adjacent channels varies between 
							1~2ms, low pulse width is 0.4ms, signal period is about 22.5ms.
 * @version		V1.0
 * @date			26. Nov 2013
 *
 * @par
 ******************************************************************************/
 
/* Includes ----------------------------------------------------------------- */
#include "rc_transmitter.h"

void RC_Tx_RCC_Config(RC_Tx_Object* tx)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | tx->GPIO_CLK, ENABLE);
	RCC_APB1PeriphClockCmd(tx->TIM_CLK, ENABLE);
}

void RC_Tx_GPIO_Config(RC_Tx_Object* tx)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_StructInit(&GPIO_InitStructure);
	
	GPIO_InitStructure.GPIO_Pin = tx->GPIO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(tx->GPIO_Port, &GPIO_InitStructure);
}

void RC_Tx_TIM_Config(RC_Tx_Object* tx)
{
	TIM_TimeBaseInitTypeDef TIM_BaseInitStructure; 
	TIM_ICInitTypeDef  TIM_ICInitStructure;
	
	TIM_BaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;	
	TIM_BaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_BaseInitStructure.TIM_Period = 0xFFFF;
	TIM_BaseInitStructure.TIM_Prescaler = 0;	//24MHz, overflow time (65536/24000)ms ~= 2.73ms
	TIM_TimeBaseInit(tx->TIMx, &TIM_BaseInitStructure);
	
	TIM_ICInitStructure.TIM_Channel = tx->TIM_Channel;
	TIM_ICInitStructure.TIM_ICFilter = 72;	//Sample 72 times (1us) to confirm a falling edge
	TIM_ICInitStructure.TIM_ICPolarity = tx->PPM_Polarity;
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	//One clock period, one sample
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;	//Inpput pin derectly mapped into corresponding channel
	TIM_ICInit(tx->TIMx, &TIM_ICInitStructure);
	
	TIM_UpdateRequestConfig(tx->TIMx, TIM_UpdateSource_Global);	//Only counter overflow/underflow generates an update interrupt
	
	TIM_ITConfig(tx->TIMx, tx->TIM_IT | TIM_IT_Update, ENABLE);
	TIM_Cmd(tx->TIMx, ENABLE);
}

void RC_Tx_NVIC_Config(RC_Tx_Object* tx)
{
	NVIC_InitTypeDef NVIC_InitStruct;
	
	NVIC_InitStruct.NVIC_IRQChannel = tx->TIM_IRQn;
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = tx->IRQChannelPreemptionPriority;
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = tx->IRQChannelSubPriority;
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
	
	NVIC_Init(&NVIC_InitStruct);
}

void RC_Tx_Init(RC_Tx_Object* tx)
{
	RC_Tx_RCC_Config(tx);
	RC_Tx_GPIO_Config(tx);
	RC_Tx_TIM_Config(tx);
	RC_Tx_NVIC_Config(tx);
}

void RC_Tx_IRQHandler(RC_Tx_Object* tx)
{
	static uint8_t FirstPeriodElapsed = 0, FirstEdgeDetected = 0, curChannel = 0;
	
	if(TIM_GetITStatus(tx->TIMx, tx->TIM_IT))
	{
		TIM_SetCounter(tx->TIMx, 0);
		FirstEdgeDetected = 1;
		if((curChannel > 0) && (curChannel <= tx->Max_Channel))
		{
			if(FirstPeriodElapsed)
			{
				tx->DataReady = CAPTURING;
				switch(tx->TIM_Channel)
				{
					case TIM_Channel_1:
						tx->PW[curChannel - 1] = TIM_GetCapture1(tx->TIMx);	break;
					case TIM_Channel_2:
						tx->PW[curChannel - 1] = TIM_GetCapture2(tx->TIMx);	break;
					case TIM_Channel_3:
						tx->PW[curChannel - 1] = TIM_GetCapture3(tx->TIMx);	break;
					case TIM_Channel_4:
						tx->PW[curChannel - 1] = TIM_GetCapture4(tx->TIMx);	break;
					default: 	break;
				}
			}
		}
		curChannel++;
		TIM_ClearITPendingBit(tx->TIMx, tx->TIM_IT);
	}

	if(TIM_GetITStatus(tx->TIMx, TIM_IT_Update))	//Interrupt generated by overflow
	{
		if(FirstPeriodElapsed)
		{
			if(tx->DataReady == CAPTURING)
			{
				if((curChannel - 1) == tx->Max_Channel)
					tx->DataReady = READY;
				else
					tx->CaptureErrorCount++;
				curChannel = 0;
			}
		}
		else if(FirstEdgeDetected)
		{
			FirstPeriodElapsed = 1;
			curChannel = 0;
		}
		TIM_ClearITPendingBit(tx->TIMx, TIM_IT_Update);
	}
}